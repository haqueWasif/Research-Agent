# Z-score mean reversion with basic performance metrics
import numpy as np
import pandas as pd

def run_zscore_signal(prices: pd.Series,
                      lookback: int = 60,
                      entry: float = 2.0,
                      exit: float = 0.5,
                      commission_bps: float = 2.0) -> dict:
    # TODO: Replace with your data loader (e.g., pd.read_csv(...)) and clean prices
    assert isinstance(prices, pd.Series) and prices.index.is_monotonic_increasing
    px = prices.ffill().dropna()
    daily_ret = px.pct_change().dropna()

    # Z-score of rolling mean
    mu = px.rolling(lookback, min_periods=lookback).mean()
    sigma = px.rolling(lookback, min_periods=lookback).std(ddof=0)
    z = (px - mu) / sigma.replace(0, np.nan)
    z = z.clip(lower=-10, upper=10).fillna(0)

    # Positions: long if z < -entry, short if z > entry, exit when |z| < exit
    pos = pd.Series(0.0, index=z.index)
    long_sig = z < -entry
    short_sig = z > entry
    flat_sig = z.abs() < exit

    position = 0.0
    entries, exits = 0, 0
    for i, (idx, zv) in enumerate(z.items()):
        if position == 0 and zv < -entry:
            position, entries = 1, entries + 1
        elif position == 0 and zv > entry:
            position, entries = -1, entries + 1
        elif position != 0 and abs(zv) < exit:
            position, exits = 0, exits + 1
        pos.loc[idx] = position

    strat_ret = (pos.shift(1) * daily_ret).fillna(0.0)
    net = strat_ret - np.abs(pos.diff().fillna(0.0)) * (commission_bps / 10000.0)

    # Metrics
    cum = (1.0 + net).cumprod()
    annual_factor = 252
    mean = net.mean() * annual_factor
    vol = net.std(ddof=0) * np.sqrt(annual_factor)
    ir = np.nan if vol == 0 else mean / vol
    cagr = (cum.iloc[-1] ** (annual_factor / len(net))) - 1.0 if len(net) > 0 else np.nan
    max_dd = (cum / cum.cummax() - 1.0).min()
    hit = (net[net != 0] > 0.0).sum() / max((net != 0).sum(), 1)
    entries = max(entries, 1)
    exit_rate = exits / entries

    return {
        "cumulative_return": cum.iloc[-1] - 1.0,
        "annualized_return": cagr,
        "annualized_vol": vol,
        "information_ratio": ir,
        "hit_rate": hit,
        "max_drawdown": max_dd,
        "n_trades": entries,
        "exit_rate": exit_rate,
        "positions": pos,
        "returns": net
    }

# Example usage (synthetic data); replace with your data
np.random.seed(42)
idx = pd.date_range("2018-01-01", periods=2000, freq="D")
synth = pd.Series(np.cumsum(np.random.normal(0, 0.01, size=len(idx)) + 0.0005) + 100.0, index=idx)
res = run_zscore_signal(synth)
print({k: (v.tolist() if isinstance(v, np.ndarray) else (round(float(v), 6) if isinstance(v, (int, float, np.number)) else v))
       for k, v in res.items()})